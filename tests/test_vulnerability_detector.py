"""
Tests for src/vulnerability_detector.py

Covers:
  - VulnerabilityType and Severity enums
  - VulnerabilityResult and VulnerabilityReport dataclasses
  - CFG-based bytecode scanning
  - Source-level pattern matching
  - Severity determination
  - Risk score computation
  - Summary generation
  - Recommendations
"""

import pytest
from src.vulnerability_detector import (
    VulnerabilityDetector,
    VulnerabilityReport,
    VulnerabilityResult,
    VulnerabilityType,
    Severity,
    VULNERABILITY_PROMPTS,
    CFG_VULNERABILITY_PATTERNS,
    SEVERITY_SCORES,
)


# ---------------------------------------------------------------------------
# Fixtures
# ---------------------------------------------------------------------------

@pytest.fixture
def detector():
    return VulnerabilityDetector(use_llm=False)


# Minimal bytecode with PUSH1 0x00 STOP
MINIMAL_BYTECODE = "0x600000"

# Bytecode with SELFDESTRUCT: PUSH1 0x00 SELFDESTRUCT
SELFDESTRUCT_BYTECODE = "0x6000ff"

# Bytecode with TIMESTAMP: TIMESTAMP STOP
TIMESTAMP_BYTECODE = "0x4200"

# Sample Solidity with reentrancy pattern
REENTRANCY_SOURCE = """
pragma solidity ^0.7.0;
contract Vulnerable {
    mapping(address => uint) balances;
    function withdraw(uint amount) public {
        require(balances[msg.sender] >= amount);
        msg.sender.call.value(amount)("");
        balances[msg.sender] -= amount;
    }
}
"""

# Sample safe Solidity
SAFE_SOURCE = """
pragma solidity ^0.8.0;
contract Safe {
    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    function setOwner(address newOwner) public onlyOwner {
        owner = newOwner;
    }
}
"""


# ---------------------------------------------------------------------------
# Enums and Constants
# ---------------------------------------------------------------------------

class TestEnumsAndConstants:
    def test_vulnerability_types(self):
        assert len(VulnerabilityType) == 6
        assert VulnerabilityType.REENTRANCY.value == "reentrancy"

    def test_severity_levels(self):
        assert len(Severity) == 5
        assert Severity.CRITICAL.value == "critical"

    def test_all_vuln_types_have_prompts(self):
        for vt in VulnerabilityType:
            assert vt in VULNERABILITY_PROMPTS

    def test_all_vuln_types_have_patterns(self):
        for vt in VulnerabilityType:
            assert vt in CFG_VULNERABILITY_PATTERNS

    def test_severity_scores_complete(self):
        for sev in Severity:
            assert sev in SEVERITY_SCORES


# ---------------------------------------------------------------------------
# VulnerabilityResult Dataclass
# ---------------------------------------------------------------------------

class TestVulnerabilityResult:
    def test_creation(self):
        result = VulnerabilityResult(
            vulnerability_type=VulnerabilityType.REENTRANCY,
            detected=True,
            confidence=0.85,
            severity=Severity.HIGH,
            explanation="Test",
        )
        assert result.detected is True
        assert result.confidence == 0.85

    def test_default_values(self):
        result = VulnerabilityResult(
            vulnerability_type=VulnerabilityType.REENTRANCY,
            detected=False,
            confidence=0.5,
            severity=Severity.INFO,
        )
        assert result.explanation == ""
        assert result.metadata == {}


# ---------------------------------------------------------------------------
# VulnerabilityReport Dataclass
# ---------------------------------------------------------------------------

class TestVulnerabilityReport:
    def test_no_vulnerabilities(self):
        report = VulnerabilityReport()
        assert report.has_vulnerabilities is False
        assert report.critical_count == 0

    def test_with_vulnerabilities(self):
        vulns = [
            VulnerabilityResult(VulnerabilityType.REENTRANCY, True, 0.9, Severity.HIGH),
            VulnerabilityResult(VulnerabilityType.SELFDESTRUCT, True, 0.95, Severity.CRITICAL),
            VulnerabilityResult(VulnerabilityType.TIMESTAMP_DEPENDENCY, False, 0.8, Severity.INFO),
        ]
        report = VulnerabilityReport(vulnerabilities=vulns)
        assert report.has_vulnerabilities is True
        assert report.critical_count == 1
        assert report.high_count == 1


# ---------------------------------------------------------------------------
# Bytecode Scanning
# ---------------------------------------------------------------------------

class TestBytecodeScanning:
    def test_scan_minimal_bytecode(self, detector):
        report = detector.scan_from_bytecode(MINIMAL_BYTECODE)
        assert isinstance(report, VulnerabilityReport)
        assert len(report.vulnerabilities) == 6  # one per type

    def test_scan_selfdestruct_bytecode(self, detector):
        report = detector.scan_from_bytecode(SELFDESTRUCT_BYTECODE)
        sd_results = [
            v for v in report.vulnerabilities
            if v.vulnerability_type == VulnerabilityType.SELFDESTRUCT
        ]
        assert len(sd_results) == 1
        # SELFDESTRUCT opcode should be detected
        if sd_results[0].detected:
            assert sd_results[0].severity in (Severity.CRITICAL, Severity.HIGH)

    def test_scan_timestamp_bytecode(self, detector):
        report = detector.scan_from_bytecode(TIMESTAMP_BYTECODE)
        ts_results = [
            v for v in report.vulnerabilities
            if v.vulnerability_type == VulnerabilityType.TIMESTAMP_DEPENDENCY
        ]
        assert len(ts_results) == 1

    def test_scan_with_contract_address(self, detector):
        report = detector.scan_from_bytecode(MINIMAL_BYTECODE, "0x1234")
        assert report.contract_address == "0x1234"

    def test_risk_score_range(self, detector):
        report = detector.scan_from_bytecode(MINIMAL_BYTECODE)
        assert 0.0 <= report.risk_score <= 1.0

    def test_summary_generated(self, detector):
        report = detector.scan_from_bytecode(MINIMAL_BYTECODE)
        assert isinstance(report.summary, str)
        assert len(report.summary) > 0


# ---------------------------------------------------------------------------
# Source-Level Scanning
# ---------------------------------------------------------------------------

class TestSourceScanning:
    def test_scan_reentrancy_source(self, detector):
        report = detector.scan_from_source(REENTRANCY_SOURCE)
        re_results = [
            v for v in report.vulnerabilities
            if v.vulnerability_type == VulnerabilityType.REENTRANCY
        ]
        assert len(re_results) == 1
        assert re_results[0].detected is True

    def test_scan_safe_source(self, detector):
        report = detector.scan_from_source(SAFE_SOURCE)
        # Should have low or no detected vulnerabilities
        detected = [v for v in report.vulnerabilities if v.detected]
        # Safe contract should have minimal detections
        assert len(detected) <= 2

    def test_scan_selfdestruct_source(self, detector):
        source = "contract X { function kill() public { selfdestruct(msg.sender); } }"
        report = detector.scan_from_source(source)
        sd = [v for v in report.vulnerabilities if v.vulnerability_type == VulnerabilityType.SELFDESTRUCT]
        assert sd[0].detected is True

    def test_scan_delegatecall_source(self, detector):
        source = "contract X { function f(address a) public { a.delegatecall(''); } }"
        report = detector.scan_from_source(source)
        dc = [v for v in report.vulnerabilities if v.vulnerability_type == VulnerabilityType.DELEGATECALL]
        assert dc[0].detected is True


# ---------------------------------------------------------------------------
# Severity and Risk Score
# ---------------------------------------------------------------------------

class TestSeverityAndRisk:
    def test_determine_severity(self, detector):
        sev = detector._determine_severity(VulnerabilityType.SELFDESTRUCT, [{}])
        assert sev == Severity.CRITICAL

    def test_determine_severity_many_fragments(self, detector):
        sev = detector._determine_severity(VulnerabilityType.TIMESTAMP_DEPENDENCY, [{}, {}, {}, {}])
        assert sev == Severity.HIGH

    def test_compute_risk_score_empty(self, detector):
        score = detector._compute_risk_score([])
        assert score == 0.0

    def test_compute_risk_score_no_detections(self, detector):
        results = [
            VulnerabilityResult(VulnerabilityType.REENTRANCY, False, 0.9, Severity.INFO),
        ]
        score = detector._compute_risk_score(results)
        assert score == 0.0

    def test_compute_risk_score_critical(self, detector):
        results = [
            VulnerabilityResult(VulnerabilityType.SELFDESTRUCT, True, 1.0, Severity.CRITICAL),
        ]
        score = detector._compute_risk_score(results)
        assert score > 0.0

    def test_recommendation_exists(self, detector):
        for vt in VulnerabilityType:
            rec = detector._get_recommendation(vt)
            assert len(rec) > 0
