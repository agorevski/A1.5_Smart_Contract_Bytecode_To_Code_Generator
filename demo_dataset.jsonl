{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction getOwner:\n  temp_1 = storage[0x0]\n  return temp_1", "output": "function getOwner() public view returns (address) {\n    return owner;\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction changeOwner:\n  temp_1 = msg.sender\n  temp_2 = storage[0x0]\n  temp_3 = temp_1 == temp_2\n  if temp_3 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  storage[0x0] = newOwner", "output": "function changeOwner(address newOwner) public {\n    require(msg.sender == owner, \"Not authorized\");\n    owner = newOwner;\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction totalSupply:\n  temp_1 = storage[0x2]\n  return temp_1", "output": "function totalSupply() public view returns (uint256) {\n    return _totalSupply;\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction balanceOf:\n  temp_1 = calldataload(0x4)\n  temp_2 = mapping_load(storage[0x3], temp_1)\n  return temp_2", "output": "function balanceOf(address account) public view returns (uint256) {\n    return _balances[account];\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction transfer:\n  temp_1 = calldataload(0x4)\n  temp_2 = calldataload(0x24)\n  temp_3 = msg.sender\n  temp_4 = mapping_load(storage[0x3], temp_3)\n  temp_5 = temp_4 >= temp_2\n  if temp_5 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  temp_6 = temp_4 - temp_2\n  mapping_store(storage[0x3], temp_3, temp_6)\n  temp_7 = mapping_load(storage[0x3], temp_1)\n  temp_8 = temp_7 + temp_2\n  mapping_store(storage[0x3], temp_1, temp_8)\n  emit Transfer(temp_3, temp_1, temp_2)\n  return 0x1", "output": "function transfer(address to, uint256 amount) public returns (bool) {\n    require(_balances[msg.sender] >= amount, \"Insufficient balance\");\n    _balances[msg.sender] -= amount;\n    _balances[to] += amount;\n    emit Transfer(msg.sender, to, amount);\n    return true;\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction approve:\n  temp_1 = calldataload(0x4)\n  temp_2 = calldataload(0x24)\n  temp_3 = msg.sender\n  mapping_store(storage[0x4], temp_3, temp_1, temp_2)\n  emit Approval(temp_3, temp_1, temp_2)\n  return 0x1", "output": "function approve(address spender, uint256 amount) public returns (bool) {\n    _allowances[msg.sender][spender] = amount;\n    emit Approval(msg.sender, spender, amount);\n    return true;\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction allowance:\n  temp_1 = calldataload(0x4)\n  temp_2 = calldataload(0x24)\n  temp_3 = mapping_load(storage[0x4], temp_1, temp_2)\n  return temp_3", "output": "function allowance(address owner, address spender) public view returns (uint256) {\n    return _allowances[owner][spender];\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction transferFrom:\n  temp_1 = calldataload(0x4)\n  temp_2 = calldataload(0x24)\n  temp_3 = calldataload(0x44)\n  temp_4 = msg.sender\n  temp_5 = mapping_load(storage[0x4], temp_1, temp_4)\n  temp_6 = temp_5 >= temp_3\n  if temp_6 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  temp_7 = mapping_load(storage[0x3], temp_1)\n  temp_8 = temp_7 >= temp_3\n  if temp_8 goto block_2\n  revert memory[0x0:0x20]\n  \n  block_2:\n  temp_9 = temp_5 - temp_3\n  mapping_store(storage[0x4], temp_1, temp_4, temp_9)\n  temp_10 = temp_7 - temp_3\n  mapping_store(storage[0x3], temp_1, temp_10)\n  temp_11 = mapping_load(storage[0x3], temp_2)\n  temp_12 = temp_11 + temp_3\n  mapping_store(storage[0x3], temp_2, temp_12)\n  emit Transfer(temp_1, temp_2, temp_3)\n  return 0x1", "output": "function transferFrom(address from, address to, uint256 amount) public returns (bool) {\n    require(_allowances[from][msg.sender] >= amount, \"Insufficient allowance\");\n    require(_balances[from] >= amount, \"Insufficient balance\");\n    _allowances[from][msg.sender] -= amount;\n    _balances[from] -= amount;\n    _balances[to] += amount;\n    emit Transfer(from, to, amount);\n    return true;\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction name:\n  temp_1 = storage[0x5]\n  return temp_1", "output": "function name() public view returns (string memory) {\n    return _name;\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction symbol:\n  temp_1 = storage[0x6]\n  return temp_1", "output": "function symbol() public view returns (string memory) {\n    return _symbol;\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction decimals:\n  return 0x12", "output": "function decimals() public pure returns (uint8) {\n    return 18;\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction mint:\n  temp_1 = msg.sender\n  temp_2 = storage[0x0]\n  temp_3 = temp_1 == temp_2\n  if temp_3 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  temp_4 = calldataload(0x4)\n  temp_5 = calldataload(0x24)\n  temp_6 = storage[0x2]\n  temp_7 = temp_6 + temp_5\n  storage[0x2] = temp_7\n  temp_8 = mapping_load(storage[0x3], temp_4)\n  temp_9 = temp_8 + temp_5\n  mapping_store(storage[0x3], temp_4, temp_9)\n  emit Transfer(0x0, temp_4, temp_5)", "output": "function mint(address to, uint256 amount) public {\n    require(msg.sender == owner, \"Only owner\");\n    _totalSupply += amount;\n    _balances[to] += amount;\n    emit Transfer(address(0), to, amount);\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction burn:\n  temp_1 = calldataload(0x4)\n  temp_2 = msg.sender\n  temp_3 = mapping_load(storage[0x3], temp_2)\n  temp_4 = temp_3 >= temp_1\n  if temp_4 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  temp_5 = temp_3 - temp_1\n  mapping_store(storage[0x3], temp_2, temp_5)\n  temp_6 = storage[0x2]\n  temp_7 = temp_6 - temp_1\n  storage[0x2] = temp_7\n  emit Transfer(temp_2, 0x0, temp_1)", "output": "function burn(uint256 amount) public {\n    require(_balances[msg.sender] >= amount, \"Insufficient balance\");\n    _balances[msg.sender] -= amount;\n    _totalSupply -= amount;\n    emit Transfer(msg.sender, address(0), amount);\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction pause:\n  temp_1 = msg.sender\n  temp_2 = storage[0x0]\n  temp_3 = temp_1 == temp_2\n  if temp_3 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  storage[0x7] = 0x1\n  emit Paused(temp_1)", "output": "function pause() public {\n    require(msg.sender == owner, \"Only owner\");\n    _paused = true;\n    emit Paused(msg.sender);\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction unpause:\n  temp_1 = msg.sender\n  temp_2 = storage[0x0]\n  temp_3 = temp_1 == temp_2\n  if temp_3 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  storage[0x7] = 0x0\n  emit Unpaused(temp_1)", "output": "function unpause() public {\n    require(msg.sender == owner, \"Only owner\");\n    _paused = false;\n    emit Unpaused(msg.sender);\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction paused:\n  temp_1 = storage[0x7]\n  return temp_1", "output": "function paused() public view returns (bool) {\n    return _paused;\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction renounceOwnership:\n  temp_1 = msg.sender\n  temp_2 = storage[0x0]\n  temp_3 = temp_1 == temp_2\n  if temp_3 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  emit OwnershipTransferred(temp_2, 0x0)\n  storage[0x0] = 0x0", "output": "function renounceOwnership() public {\n    require(msg.sender == owner, \"Only owner\");\n    emit OwnershipTransferred(owner, address(0));\n    owner = address(0);\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction transferOwnership:\n  temp_1 = calldataload(0x4)\n  temp_2 = msg.sender\n  temp_3 = storage[0x0]\n  temp_4 = temp_2 == temp_3\n  if temp_4 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  temp_5 = temp_1 != 0x0\n  if temp_5 goto block_2\n  revert memory[0x0:0x20]\n  \n  block_2:\n  emit OwnershipTransferred(temp_3, temp_1)\n  storage[0x0] = temp_1", "output": "function transferOwnership(address newOwner) public {\n    require(msg.sender == owner, \"Only owner\");\n    require(newOwner != address(0), \"Zero address\");\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction withdraw:\n  temp_1 = msg.sender\n  temp_2 = storage[0x0]\n  temp_3 = temp_1 == temp_2\n  if temp_3 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  temp_4 = balance(address(this))\n  call(temp_1, temp_4)\n  temp_5 = success\n  if temp_5 goto block_2\n  revert memory[0x0:0x20]\n  \n  block_2:\n  return", "output": "function withdraw() public {\n    require(msg.sender == owner, \"Only owner\");\n    uint256 balance = address(this).balance;\n    (bool success, ) = msg.sender.call{value: balance}(\"\");\n    require(success, \"Transfer failed\");\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction deposit:\n  temp_1 = msg.value\n  temp_2 = msg.sender\n  temp_3 = mapping_load(storage[0x3], temp_2)\n  temp_4 = temp_3 + temp_1\n  mapping_store(storage[0x3], temp_2, temp_4)\n  emit Deposit(temp_2, temp_1)", "output": "function deposit() public payable {\n    _balances[msg.sender] += msg.value;\n    emit Deposit(msg.sender, msg.value);\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction getBalance:\n  temp_1 = calldataload(0x4)\n  temp_2 = mapping_load(storage[0x3], temp_1)\n  return temp_2", "output": "function getBalance(address account) public view returns (uint256) {\n    return _balances[account];\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction setApprovalForAll:\n  temp_1 = calldataload(0x4)\n  temp_2 = calldataload(0x24)\n  temp_3 = msg.sender\n  mapping_store(storage[0x5], temp_3, temp_1, temp_2)\n  emit ApprovalForAll(temp_3, temp_1, temp_2)", "output": "function setApprovalForAll(address operator, bool approved) public {\n    _operatorApprovals[msg.sender][operator] = approved;\n    emit ApprovalForAll(msg.sender, operator, approved);\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction isApprovedForAll:\n  temp_1 = calldataload(0x4)\n  temp_2 = calldataload(0x24)\n  temp_3 = mapping_load(storage[0x5], temp_1, temp_2)\n  return temp_3", "output": "function isApprovedForAll(address owner, address operator) public view returns (bool) {\n    return _operatorApprovals[owner][operator];\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction ownerOf:\n  temp_1 = calldataload(0x4)\n  temp_2 = mapping_load(storage[0x6], temp_1)\n  temp_3 = temp_2 != 0x0\n  if temp_3 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  return temp_2", "output": "function ownerOf(uint256 tokenId) public view returns (address) {\n    address tokenOwner = _owners[tokenId];\n    require(tokenOwner != address(0), \"Token does not exist\");\n    return tokenOwner;\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction getApproved:\n  temp_1 = calldataload(0x4)\n  temp_2 = mapping_load(storage[0x6], temp_1)\n  temp_3 = temp_2 != 0x0\n  if temp_3 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  temp_4 = mapping_load(storage[0x7], temp_1)\n  return temp_4", "output": "function getApproved(uint256 tokenId) public view returns (address) {\n    require(_owners[tokenId] != address(0), \"Token does not exist\");\n    return _tokenApprovals[tokenId];\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction setPrice:\n  temp_1 = calldataload(0x4)\n  temp_2 = msg.sender\n  temp_3 = storage[0x0]\n  temp_4 = temp_2 == temp_3\n  if temp_4 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  storage[0x8] = temp_1\n  emit PriceUpdated(temp_1)", "output": "function setPrice(uint256 newPrice) public {\n    require(msg.sender == owner, \"Only owner\");\n    price = newPrice;\n    emit PriceUpdated(newPrice);\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction getPrice:\n  temp_1 = storage[0x8]\n  return temp_1", "output": "function getPrice() public view returns (uint256) {\n    return price;\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction addToWhitelist:\n  temp_1 = calldataload(0x4)\n  temp_2 = msg.sender\n  temp_3 = storage[0x0]\n  temp_4 = temp_2 == temp_3\n  if temp_4 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  mapping_store(storage[0x9], temp_1, 0x1)", "output": "function addToWhitelist(address account) public {\n    require(msg.sender == owner, \"Only owner\");\n    whitelist[account] = true;\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction removeFromWhitelist:\n  temp_1 = calldataload(0x4)\n  temp_2 = msg.sender\n  temp_3 = storage[0x0]\n  temp_4 = temp_2 == temp_3\n  if temp_4 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  mapping_store(storage[0x9], temp_1, 0x0)", "output": "function removeFromWhitelist(address account) public {\n    require(msg.sender == owner, \"Only owner\");\n    whitelist[account] = false;\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction isWhitelisted:\n  temp_1 = calldataload(0x4)\n  temp_2 = mapping_load(storage[0x9], temp_1)\n  return temp_2", "output": "function isWhitelisted(address account) public view returns (bool) {\n    return whitelist[account];\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction setMaxSupply:\n  temp_1 = calldataload(0x4)\n  temp_2 = msg.sender\n  temp_3 = storage[0x0]\n  temp_4 = temp_2 == temp_3\n  if temp_4 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  storage[0xa] = temp_1", "output": "function setMaxSupply(uint256 newMaxSupply) public {\n    require(msg.sender == owner, \"Only owner\");\n    maxSupply = newMaxSupply;\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction maxSupply:\n  temp_1 = storage[0xa]\n  return temp_1", "output": "function maxSupply() public view returns (uint256) {\n    return _maxSupply;\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction increaseAllowance:\n  temp_1 = calldataload(0x4)\n  temp_2 = calldataload(0x24)\n  temp_3 = msg.sender\n  temp_4 = mapping_load(storage[0x4], temp_3, temp_1)\n  temp_5 = temp_4 + temp_2\n  mapping_store(storage[0x4], temp_3, temp_1, temp_5)\n  emit Approval(temp_3, temp_1, temp_5)\n  return 0x1", "output": "function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n    _allowances[msg.sender][spender] += addedValue;\n    emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);\n    return true;\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction decreaseAllowance:\n  temp_1 = calldataload(0x4)\n  temp_2 = calldataload(0x24)\n  temp_3 = msg.sender\n  temp_4 = mapping_load(storage[0x4], temp_3, temp_1)\n  temp_5 = temp_4 >= temp_2\n  if temp_5 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  temp_6 = temp_4 - temp_2\n  mapping_store(storage[0x4], temp_3, temp_1, temp_6)\n  emit Approval(temp_3, temp_1, temp_6)\n  return 0x1", "output": "function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n    require(_allowances[msg.sender][spender] >= subtractedValue, \"Decreased below zero\");\n    _allowances[msg.sender][spender] -= subtractedValue;\n    emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);\n    return true;\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction receive:\n  temp_1 = msg.value\n  temp_2 = msg.sender\n  emit Received(temp_2, temp_1)", "output": "receive() external payable {\n    emit Received(msg.sender, msg.value);\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction fallback:\n  revert memory[0x0:0x0]", "output": "fallback() external {\n    revert();\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction setFee:\n  temp_1 = calldataload(0x4)\n  temp_2 = msg.sender\n  temp_3 = storage[0x0]\n  temp_4 = temp_2 == temp_3\n  if temp_4 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  temp_5 = temp_1 <= 0x64\n  if temp_5 goto block_2\n  revert memory[0x0:0x20]\n  \n  block_2:\n  storage[0xb] = temp_1\n  emit FeeUpdated(temp_1)", "output": "function setFee(uint256 newFee) public {\n    require(msg.sender == owner, \"Only owner\");\n    require(newFee <= 100, \"Fee too high\");\n    fee = newFee;\n    emit FeeUpdated(newFee);\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction getFee:\n  temp_1 = storage[0xb]\n  return temp_1", "output": "function getFee() public view returns (uint256) {\n    return fee;\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction lock:\n  temp_1 = calldataload(0x4)\n  temp_2 = msg.sender\n  temp_3 = mapping_load(storage[0x3], temp_2)\n  temp_4 = temp_3 >= temp_1\n  if temp_4 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  temp_5 = temp_3 - temp_1\n  mapping_store(storage[0x3], temp_2, temp_5)\n  temp_6 = mapping_load(storage[0xc], temp_2)\n  temp_7 = temp_6 + temp_1\n  mapping_store(storage[0xc], temp_2, temp_7)\n  emit Locked(temp_2, temp_1)", "output": "function lock(uint256 amount) public {\n    require(_balances[msg.sender] >= amount, \"Insufficient balance\");\n    _balances[msg.sender] -= amount;\n    _locked[msg.sender] += amount;\n    emit Locked(msg.sender, amount);\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction unlock:\n  temp_1 = calldataload(0x4)\n  temp_2 = msg.sender\n  temp_3 = mapping_load(storage[0xc], temp_2)\n  temp_4 = temp_3 >= temp_1\n  if temp_4 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  temp_5 = temp_3 - temp_1\n  mapping_store(storage[0xc], temp_2, temp_5)\n  temp_6 = mapping_load(storage[0x3], temp_2)\n  temp_7 = temp_6 + temp_1\n  mapping_store(storage[0x3], temp_2, temp_7)\n  emit Unlocked(temp_2, temp_1)", "output": "function unlock(uint256 amount) public {\n    require(_locked[msg.sender] >= amount, \"Insufficient locked balance\");\n    _locked[msg.sender] -= amount;\n    _balances[msg.sender] += amount;\n    emit Unlocked(msg.sender, amount);\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction lockedBalance:\n  temp_1 = calldataload(0x4)\n  temp_2 = mapping_load(storage[0xc], temp_1)\n  return temp_2", "output": "function lockedBalance(address account) public view returns (uint256) {\n    return _locked[account];\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction supportsInterface:\n  temp_1 = calldataload(0x4)\n  temp_2 = temp_1 == 0x01ffc9a7\n  if temp_2 goto block_true\n  temp_3 = temp_1 == 0x80ac58cd\n  if temp_3 goto block_true\n  temp_4 = temp_1 == 0x5b5e139f\n  if temp_4 goto block_true\n  return 0x0\n  \n  block_true:\n  return 0x1", "output": "function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\n    return interfaceId == type(IERC165).interfaceId ||\n           interfaceId == type(IERC721).interfaceId ||\n           interfaceId == type(IERC721Metadata).interfaceId;\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction setBaseURI:\n  temp_1 = calldataload(0x4)\n  temp_2 = msg.sender\n  temp_3 = storage[0x0]\n  temp_4 = temp_2 == temp_3\n  if temp_4 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  storage[0xd] = temp_1", "output": "function setBaseURI(string memory newBaseURI) public {\n    require(msg.sender == owner, \"Only owner\");\n    baseURI = newBaseURI;\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction tokenURI:\n  temp_1 = calldataload(0x4)\n  temp_2 = mapping_load(storage[0x6], temp_1)\n  temp_3 = temp_2 != 0x0\n  if temp_3 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  temp_4 = storage[0xd]\n  temp_5 = concat(temp_4, toString(temp_1))\n  return temp_5", "output": "function tokenURI(uint256 tokenId) public view returns (string memory) {\n    require(_owners[tokenId] != address(0), \"Token does not exist\");\n    return string(abi.encodePacked(baseURI, Strings.toString(tokenId)));\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction stake:\n  temp_1 = calldataload(0x4)\n  temp_2 = msg.sender\n  temp_3 = mapping_load(storage[0x3], temp_2)\n  temp_4 = temp_3 >= temp_1\n  if temp_4 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  temp_5 = temp_3 - temp_1\n  mapping_store(storage[0x3], temp_2, temp_5)\n  temp_6 = mapping_load(storage[0xe], temp_2)\n  temp_7 = temp_6 + temp_1\n  mapping_store(storage[0xe], temp_2, temp_7)\n  mapping_store(storage[0xf], temp_2, block.timestamp)\n  emit Staked(temp_2, temp_1)", "output": "function stake(uint256 amount) public {\n    require(_balances[msg.sender] >= amount, \"Insufficient balance\");\n    _balances[msg.sender] -= amount;\n    _staked[msg.sender] += amount;\n    _stakeTimestamp[msg.sender] = block.timestamp;\n    emit Staked(msg.sender, amount);\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction unstake:\n  temp_1 = calldataload(0x4)\n  temp_2 = msg.sender\n  temp_3 = mapping_load(storage[0xe], temp_2)\n  temp_4 = temp_3 >= temp_1\n  if temp_4 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  temp_5 = temp_3 - temp_1\n  mapping_store(storage[0xe], temp_2, temp_5)\n  temp_6 = mapping_load(storage[0x3], temp_2)\n  temp_7 = temp_6 + temp_1\n  mapping_store(storage[0x3], temp_2, temp_7)\n  emit Unstaked(temp_2, temp_1)", "output": "function unstake(uint256 amount) public {\n    require(_staked[msg.sender] >= amount, \"Insufficient staked balance\");\n    _staked[msg.sender] -= amount;\n    _balances[msg.sender] += amount;\n    emit Unstaked(msg.sender, amount);\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction stakedBalance:\n  temp_1 = calldataload(0x4)\n  temp_2 = mapping_load(storage[0xe], temp_1)\n  return temp_2", "output": "function stakedBalance(address account) public view returns (uint256) {\n    return _staked[account];\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction setAdmin:\n  temp_1 = calldataload(0x4)\n  temp_2 = msg.sender\n  temp_3 = storage[0x0]\n  temp_4 = temp_2 == temp_3\n  if temp_4 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  storage[0x1] = temp_1\n  emit AdminChanged(temp_1)", "output": "function setAdmin(address newAdmin) public {\n    require(msg.sender == owner, \"Only owner\");\n    admin = newAdmin;\n    emit AdminChanged(newAdmin);\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction getAdmin:\n  temp_1 = storage[0x1]\n  return temp_1", "output": "function getAdmin() public view returns (address) {\n    return admin;\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction emergencyWithdraw:\n  temp_1 = msg.sender\n  temp_2 = storage[0x0]\n  temp_3 = temp_1 == temp_2\n  if temp_3 goto block_check\n  temp_4 = storage[0x1]\n  temp_5 = temp_1 == temp_4\n  if temp_5 goto block_check\n  revert memory[0x0:0x20]\n  \n  block_check:\n  temp_6 = calldataload(0x4)\n  temp_7 = calldataload(0x24)\n  call(temp_6, temp_7)\n  temp_8 = success\n  if temp_8 goto block_done\n  revert memory[0x0:0x20]\n  \n  block_done:\n  emit EmergencyWithdraw(temp_6, temp_7)", "output": "function emergencyWithdraw(address to, uint256 amount) public {\n    require(msg.sender == owner || msg.sender == admin, \"Not authorized\");\n    (bool success, ) = to.call{value: amount}(\"\");\n    require(success, \"Transfer failed\");\n    emit EmergencyWithdraw(to, amount);\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction vote:\n  temp_1 = calldataload(0x4)\n  temp_2 = msg.sender\n  temp_3 = mapping_load(storage[0x10], temp_2)\n  temp_4 = temp_3 == 0x0\n  if temp_4 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  mapping_store(storage[0x10], temp_2, 0x1)\n  temp_5 = mapping_load(storage[0x11], temp_1)\n  temp_6 = temp_5 + 0x1\n  mapping_store(storage[0x11], temp_1, temp_6)\n  emit Voted(temp_2, temp_1)", "output": "function vote(uint256 proposalId) public {\n    require(!hasVoted[msg.sender], \"Already voted\");\n    hasVoted[msg.sender] = true;\n    voteCount[proposalId] += 1;\n    emit Voted(msg.sender, proposalId);\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction getVotes:\n  temp_1 = calldataload(0x4)\n  temp_2 = mapping_load(storage[0x11], temp_1)\n  return temp_2", "output": "function getVotes(uint256 proposalId) public view returns (uint256) {\n    return voteCount[proposalId];\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction setDeadline:\n  temp_1 = calldataload(0x4)\n  temp_2 = msg.sender\n  temp_3 = storage[0x0]\n  temp_4 = temp_2 == temp_3\n  if temp_4 goto block_1\n  revert memory[0x0:0x20]\n  \n  block_1:\n  temp_5 = temp_1 > block.timestamp\n  if temp_5 goto block_2\n  revert memory[0x0:0x20]\n  \n  block_2:\n  storage[0x12] = temp_1\n  emit DeadlineSet(temp_1)", "output": "function setDeadline(uint256 newDeadline) public {\n    require(msg.sender == owner, \"Only owner\");\n    require(newDeadline > block.timestamp, \"Deadline in past\");\n    deadline = newDeadline;\n    emit DeadlineSet(newDeadline);\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction getDeadline:\n  temp_1 = storage[0x12]\n  return temp_1", "output": "function getDeadline() public view returns (uint256) {\n    return deadline;\n}"}
{"input": "// Three-Address Code Representation\n// Generated from EVM bytecode analysis\n\nfunction isActive:\n  temp_1 = storage[0x12]\n  temp_2 = block.timestamp\n  temp_3 = temp_2 < temp_1\n  return temp_3", "output": "function isActive() public view returns (bool) {\n    return block.timestamp < deadline;\n}"}