"""
Vulnerability Detection Model for Smart Contracts

Combines approaches from multiple research papers:
- Smart-LLaMA-DPO (2506.18245v1): LLM-based vulnerability detection with explanations
- SmartBugBert (2504.05002v2): CFG + semantic feature analysis
- SAEL (2507.22371v1): Mixture-of-experts approach
- LLMBugScanner (2512.02069v1): Ensemble learning

Detects: Reentrancy, Timestamp Dependency, Integer Overflow/Underflow,
         Delegatecall, Access Control, Self-Destruct vulnerabilities.
"""

import logging
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Optional

logger = logging.getLogger(__name__)


class VulnerabilityType(Enum):
    """Supported vulnerability types based on research taxonomy."""
    REENTRANCY = "reentrancy"
    TIMESTAMP_DEPENDENCY = "timestamp_dependency"
    INTEGER_OVERFLOW = "integer_overflow"
    DELEGATECALL = "delegatecall"
    ACCESS_CONTROL = "access_control"
    SELFDESTRUCT = "selfdestruct"


class Severity(Enum):
    """Vulnerability severity levels."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


@dataclass
class VulnerabilityResult:
    """Result of a single vulnerability detection."""
    vulnerability_type: VulnerabilityType
    detected: bool
    confidence: float
    severity: Severity
    explanation: str = ""
    location: str = ""
    recommendation: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class VulnerabilityReport:
    """Complete vulnerability scan results for a contract."""
    contract_address: str = ""
    vulnerabilities: List[VulnerabilityResult] = field(default_factory=list)
    summary: str = ""
    risk_score: float = 0.0
    scan_metadata: Dict[str, Any] = field(default_factory=dict)

    @property
    def has_vulnerabilities(self) -> bool:
        return any(v.detected for v in self.vulnerabilities)

    @property
    def critical_count(self) -> int:
        return sum(
            1 for v in self.vulnerabilities
            if v.detected and v.severity == Severity.CRITICAL
        )

    @property
    def high_count(self) -> int:
        return sum(
            1 for v in self.vulnerabilities
            if v.detected and v.severity == Severity.HIGH
        )


# Prompt templates inspired by Smart-LLaMA-DPO and SAEL papers
VULNERABILITY_PROMPTS = {
    VulnerabilityType.REENTRANCY: (
        "Analyze this smart contract code for reentrancy vulnerabilities.\n"
        "Focus on:\n"
        "1. Use of call.value(), send(), or transfer() for external calls\n"
        "2. State changes (SSTORE) occurring after external calls\n"
        "3. Missing reentrancy guards (mutex/nonReentrant modifiers)\n"
        "4. Cross-function reentrancy via shared state\n\n"
        "Contract code:\n{code}\n\n"
        "Respond with vulnerability assessment and detailed explanation."
    ),
    VulnerabilityType.TIMESTAMP_DEPENDENCY: (
        "Analyze this smart contract code for timestamp dependency vulnerabilities.\n"
        "Focus on:\n"
        "1. Use of block.timestamp or 'now' in critical logic\n"
        "2. Timestamp-based random number generation\n"
        "3. Time constraints in financial operations\n"
        "4. Miner manipulation potential\n\n"
        "Contract code:\n{code}\n\n"
        "Respond with vulnerability assessment and detailed explanation."
    ),
    VulnerabilityType.INTEGER_OVERFLOW: (
        "Analyze this smart contract code for integer overflow/underflow.\n"
        "Focus on:\n"
        "1. Arithmetic operations on uint variables without SafeMath\n"
        "2. Solidity version (0.8.x has built-in checks)\n"
        "3. Use of 'unchecked' blocks\n"
        "4. Type conversions that may truncate values\n\n"
        "Contract code:\n{code}\n\n"
        "Respond with vulnerability assessment and detailed explanation."
    ),
    VulnerabilityType.DELEGATECALL: (
        "Analyze this smart contract code for delegatecall vulnerabilities.\n"
        "Focus on:\n"
        "1. Use of delegatecall() to external contracts\n"
        "2. Storage layout compatibility in proxy patterns\n"
        "3. Access control on delegatecall targets\n"
        "4. Context preservation risks\n\n"
        "Contract code:\n{code}\n\n"
        "Respond with vulnerability assessment and detailed explanation."
    ),
    VulnerabilityType.ACCESS_CONTROL: (
        "Analyze this smart contract code for access control vulnerabilities.\n"
        "Focus on:\n"
        "1. Missing onlyOwner or role-based modifiers on sensitive functions\n"
        "2. tx.origin usage instead of msg.sender\n"
        "3. Unprotected initialization functions\n"
        "4. Privilege escalation paths\n\n"
        "Contract code:\n{code}\n\n"
        "Respond with vulnerability assessment and detailed explanation."
    ),
    VulnerabilityType.SELFDESTRUCT: (
        "Analyze this smart contract code for self-destruct vulnerabilities.\n"
        "Focus on:\n"
        "1. Presence of selfdestruct/suicide operations\n"
        "2. Access control on self-destruct functions\n"
        "3. Forced Ether sending via selfdestruct\n"
        "4. Impact on dependent contracts\n\n"
        "Contract code:\n{code}\n\n"
        "Respond with vulnerability assessment and detailed explanation."
    ),
}

# CFG pattern signatures for each vulnerability type
CFG_VULNERABILITY_PATTERNS = {
    VulnerabilityType.REENTRANCY: {
        "opcodes": ["CALL", "CALLCODE"],
        "followed_by": ["SSTORE"],
        "description": "External call followed by state modification",
    },
    VulnerabilityType.TIMESTAMP_DEPENDENCY: {
        "opcodes": ["TIMESTAMP"],
        "followed_by": [],
        "description": "Block timestamp used in execution logic",
    },
    VulnerabilityType.INTEGER_OVERFLOW: {
        "opcodes": ["ADD", "SUB", "MUL"],
        "missing": ["LT", "GT", "EQ"],
        "description": "Arithmetic without overflow protection",
    },
    VulnerabilityType.DELEGATECALL: {
        "opcodes": ["DELEGATECALL"],
        "followed_by": [],
        "description": "Delegatecall to external contract",
    },
    VulnerabilityType.ACCESS_CONTROL: {
        "missing_before_sensitive": ["CALLER", "EQ"],
        "sensitive": ["SELFDESTRUCT", "DELEGATECALL", "SSTORE"],
        "description": "Missing caller verification before sensitive operation",
    },
    VulnerabilityType.SELFDESTRUCT: {
        "opcodes": ["SELFDESTRUCT"],
        "followed_by": [],
        "description": "Self-destruct capability present",
    },
}

SEVERITY_SCORES = {
    Severity.CRITICAL: 1.0,
    Severity.HIGH: 0.8,
    Severity.MEDIUM: 0.5,
    Severity.LOW: 0.2,
    Severity.INFO: 0.0,
}


class VulnerabilityDetector:
    """
    Detects smart contract vulnerabilities using static analysis and ML.

    Combines CFG-based pattern matching (SmartBugBert approach) with
    optional LLM-based analysis (Smart-LLaMA-DPO approach) for
    explainable vulnerability detection.
    """

    def __init__(self, use_llm: bool = False, model_path: Optional[str] = None):
        """
        Args:
            use_llm: Whether to use LLM for detailed explanations.
            model_path: Path to fine-tuned vulnerability detection model.
        """
        self.use_llm = use_llm
        self.model_path = model_path
        self._model = None
        self._tokenizer = None

    def scan_from_bytecode(
        self,
        bytecode: str,
        contract_address: str = "",
    ) -> VulnerabilityReport:
        """
        Scan bytecode for vulnerabilities using CFG analysis.

        Uses the BytecodeAnalyzer to extract CFG fragments and matches
        against known vulnerability patterns.
        """
        from .bytecode_analyzer import BytecodeAnalyzer

        analyzer = BytecodeAnalyzer(bytecode)
        fragments = analyzer.extract_vulnerability_fragments()

        results = []
        for vuln_type in VulnerabilityType:
            vuln_key = vuln_type.value
            if vuln_key in fragments and fragments[vuln_key]:
                frag_list = fragments[vuln_key]
                severity = self._determine_severity(vuln_type, frag_list)
                confidence = min(0.5 + 0.1 * len(frag_list), 0.95)

                locations = ", ".join(f["block_id"] for f in frag_list)
                patterns = "; ".join(f["pattern"] for f in frag_list[:3])

                results.append(VulnerabilityResult(
                    vulnerability_type=vuln_type,
                    detected=True,
                    confidence=confidence,
                    severity=severity,
                    explanation=f"Detected {len(frag_list)} instance(s): {patterns}",
                    location=f"Blocks: {locations}",
                    recommendation=self._get_recommendation(vuln_type),
                    metadata={"fragment_count": len(frag_list)},
                ))
            else:
                results.append(VulnerabilityResult(
                    vulnerability_type=vuln_type,
                    detected=False,
                    confidence=0.9,
                    severity=Severity.INFO,
                    explanation=f"No {vuln_type.value} patterns detected in CFG analysis",
                ))

        risk_score = self._compute_risk_score(results)
        return VulnerabilityReport(
            contract_address=contract_address,
            vulnerabilities=results,
            summary=self._generate_summary(results),
            risk_score=risk_score,
            scan_metadata={"method": "cfg_analysis", "use_llm": self.use_llm},
        )

    def scan_from_source(
        self,
        source_code: str,
        contract_address: str = "",
    ) -> VulnerabilityReport:
        """
        Scan Solidity source code for vulnerabilities using pattern matching.

        Uses keyword-based heuristics for source-level analysis.
        """
        results = []
        code_lower = source_code.lower()

        for vuln_type in VulnerabilityType:
            detected, confidence, explanation = self._check_source_patterns(
                vuln_type, source_code, code_lower
            )
            severity = (
                self._determine_severity(vuln_type, [{}])
                if detected
                else Severity.INFO
            )
            results.append(VulnerabilityResult(
                vulnerability_type=vuln_type,
                detected=detected,
                confidence=confidence,
                severity=severity,
                explanation=explanation,
                recommendation=self._get_recommendation(vuln_type) if detected else "",
            ))

        risk_score = self._compute_risk_score(results)
        return VulnerabilityReport(
            contract_address=contract_address,
            vulnerabilities=results,
            summary=self._generate_summary(results),
            risk_score=risk_score,
            scan_metadata={"method": "source_analysis"},
        )

    def _check_source_patterns(
        self,
        vuln_type: VulnerabilityType,
        source: str,
        source_lower: str,
    ) -> tuple:
        """Check source code for vulnerability patterns. Returns (detected, confidence, explanation)."""
        if vuln_type == VulnerabilityType.REENTRANCY:
            has_call = ".call{value:" in source or ".call.value(" in source
            has_send = ".send(" in source_lower
            has_transfer = ".transfer(" in source_lower
            has_guard = "nonreentrant" in source_lower or "reentrancyguard" in source_lower
            if (has_call or has_send) and not has_guard:
                return True, 0.7, "External call without reentrancy guard detected"
            return False, 0.8, "No unguarded external calls detected"

        if vuln_type == VulnerabilityType.TIMESTAMP_DEPENDENCY:
            has_timestamp = "block.timestamp" in source or "now" in source
            if has_timestamp:
                return True, 0.6, "block.timestamp or 'now' used in contract logic"
            return False, 0.9, "No timestamp dependency detected"

        if vuln_type == VulnerabilityType.INTEGER_OVERFLOW:
            has_arithmetic = any(
                op in source for op in ["+=", "-=", "*=", "+", "-", "*"]
            )
            has_safemath = "safemath" in source_lower or "using SafeMath" in source
            # Solidity 0.8+ has built-in overflow checks
            has_pragma_08 = "pragma solidity ^0.8" in source or "pragma solidity >=0.8" in source
            if has_arithmetic and not has_safemath and not has_pragma_08:
                return True, 0.5, "Arithmetic operations without SafeMath or Solidity 0.8+"
            return False, 0.8, "Arithmetic operations appear protected"

        if vuln_type == VulnerabilityType.DELEGATECALL:
            if "delegatecall" in source_lower:
                return True, 0.7, "delegatecall usage detected"
            return False, 0.9, "No delegatecall usage detected"

        if vuln_type == VulnerabilityType.ACCESS_CONTROL:
            has_sensitive = "selfdestruct" in source_lower or "suicide" in source_lower
            has_owner_check = "onlyowner" in source_lower or "msg.sender == owner" in source_lower
            if has_sensitive and not has_owner_check:
                return True, 0.6, "Sensitive operation without explicit owner check"
            return False, 0.8, "Access control checks appear present"

        if vuln_type == VulnerabilityType.SELFDESTRUCT:
            if "selfdestruct" in source_lower or "suicide" in source_lower:
                return True, 0.9, "selfdestruct/suicide opcode present"
            return False, 0.95, "No selfdestruct capability"

        return False, 0.5, "Unknown vulnerability type"

    @staticmethod
    def _determine_severity(
        vuln_type: VulnerabilityType, fragments: List[Dict]
    ) -> Severity:
        """Determine severity based on vulnerability type and fragment count."""
        severity_map = {
            VulnerabilityType.REENTRANCY: Severity.HIGH,
            VulnerabilityType.SELFDESTRUCT: Severity.CRITICAL,
            VulnerabilityType.DELEGATECALL: Severity.HIGH,
            VulnerabilityType.TIMESTAMP_DEPENDENCY: Severity.MEDIUM,
            VulnerabilityType.INTEGER_OVERFLOW: Severity.MEDIUM,
            VulnerabilityType.ACCESS_CONTROL: Severity.HIGH,
        }
        base = severity_map.get(vuln_type, Severity.MEDIUM)
        if len(fragments) > 3 and base != Severity.CRITICAL:
            return Severity.HIGH
        return base

    @staticmethod
    def _get_recommendation(vuln_type: VulnerabilityType) -> str:
        """Return a mitigation recommendation for the given vulnerability type."""
        recommendations = {
            VulnerabilityType.REENTRANCY: (
                "Use the Checks-Effects-Interactions pattern. Add a reentrancy guard "
                "(e.g., OpenZeppelin's ReentrancyGuard). Complete all state changes "
                "before making external calls."
            ),
            VulnerabilityType.TIMESTAMP_DEPENDENCY: (
                "Avoid using block.timestamp for critical logic. Use block numbers "
                "or oracle-based time sources for time-sensitive operations."
            ),
            VulnerabilityType.INTEGER_OVERFLOW: (
                "Use Solidity 0.8+ which has built-in overflow checks, or use "
                "SafeMath library for earlier versions. Validate arithmetic bounds."
            ),
            VulnerabilityType.DELEGATECALL: (
                "Restrict delegatecall targets to trusted contracts. Ensure storage "
                "layout compatibility. Use the proxy pattern with proper access control."
            ),
            VulnerabilityType.ACCESS_CONTROL: (
                "Implement role-based access control (e.g., OpenZeppelin's Ownable "
                "or AccessControl). Use msg.sender instead of tx.origin."
            ),
            VulnerabilityType.SELFDESTRUCT: (
                "Remove selfdestruct if not needed. If required, protect with "
                "multi-sig or timelock. Consider impact on dependent contracts."
            ),
        }
        return recommendations.get(vuln_type, "Review and apply security best practices.")

    @staticmethod
    def _compute_risk_score(results: List[VulnerabilityResult]) -> float:
        """Compute overall risk score (0.0-1.0) from individual results."""
        if not results:
            return 0.0
        detected = [r for r in results if r.detected]
        if not detected:
            return 0.0
        total_score = sum(
            SEVERITY_SCORES[r.severity] * r.confidence for r in detected
        )
        return min(total_score / len(VulnerabilityType), 1.0)

    @staticmethod
    def _generate_summary(results: List[VulnerabilityResult]) -> str:
        """Generate a human-readable summary of scan results."""
        detected = [r for r in results if r.detected]
        if not detected:
            return "No vulnerabilities detected in static analysis."

        vuln_names = [r.vulnerability_type.value for r in detected]
        severity_counts = {}
        for r in detected:
            sev = r.severity.value
            severity_counts[sev] = severity_counts.get(sev, 0) + 1

        parts = [f"Detected {len(detected)} potential vulnerability type(s): {', '.join(vuln_names)}."]
        for sev, count in sorted(severity_counts.items()):
            parts.append(f"  {sev.upper()}: {count}")
        return "\n".join(parts)
